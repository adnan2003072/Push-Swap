
function PUSH_SWAP(stack_a):
    stack_b = empty stack
    stack_size = size(stack_a)
    
    median = GET_MEDIAN(stack_a)
    
    # Step 1: Push all elements except 3 to stack B
    while size(stack_a) > 3:
        value = top(stack_a)
        PUSH(stack_a, stack_b)  # "pb"
        
        if top(stack_b) > median AND size(stack_a) > 3:
            ROTATE(stack_b)     # "rb"

    # Step 2: Sort the remaining 3 elements in stack A
    RESOLVE_THREE(stack_a)

    # Step 3: Insert elements back from stack B to stack A in optimized order
    while not EMPTY(stack_b):
        best_index = GET_BEST_OP_INDEX(stack_b, stack_a, stack_size)
        RESOLVE_NUM(stack_b, stack_a, best_index, stack_size)
    
    # Step 4: Final rotations to fully sort stack A
    ROTATE_TO_MIN(stack_a)


### **Helper Functions**

function GET_MEDIAN(stack):
    # Return the median value of the stack
    for each element in stack:
        if IS_MEDIAN(stack, element):
            return element
    return -1

function RESOLVE_THREE(stack):
    # Sort a stack of exactly 3 elements
    if stack is not sorted:
        do minimal rotations/swaps to sort 3 elements

function RESOLVE_NUM(stack_a, stack_b, index, stack_size):
    # Optimized insertion of an element from stack_b into stack_a
    dist = GET_COHERENCES(stack_a, stack_b, index)
    RESOLVE_COHERENCES(stack_a, stack_b, index)

    # Adjust index based on rotations
    index = ADJUST_INDEX(stack_a, index, stack_size)
    
    # Rotate stack_a to the correct position for insertion
    index -= ROTATE_TO_TOP(stack_a, index)

    # Rotate stack_b to position for insertion
    if top(stack_b) < MIN(stack_a) OR top(stack_b) > MAX(stack_a):
        ROTATE_TO_TOP(stack_b, INDEX_OF_MIN(stack_b))
    else:
        ROTATE_TO_TOP(stack_b, INDEX_OF_MIN_ABOVE(stack_b, top(stack_a)))
    
    PUSH(stack_b, stack_a)  # "pa"

function ROTATE_TO_TOP(stack, index):
    # Rotate stack either up or down to bring element at index to top
    nb_op = GET_OP_FOR_TOP(stack, index)
    sign = sign(nb_op)
    while nb_op != 0:
        if sign > 0:
            ROTATE(stack)
        else:
            REVERSE_ROTATE(stack)
        nb_op -= 1
    return original nb_op with sign

function RESOLVE_COHERENCES(stack_a, stack_b, index):
    dist = GET_COHERENCES(stack_a, stack_b, index)
    while dist != 0:
        if dist > 0:
            DOUBLE_ROTATE(stack_a, stack_b)
            dist -= 1
        else:
            DOUBLE_REVERSE_ROTATE(stack_a, stack_b)
            dist += 1

function ROTATE_TO_MIN(stack):
    ROTATE_TO_TOP(stack, INDEX_OF_MIN(stack))

---

### **Summary of Key Points**

1. **Push elements to stack B** while separating smaller and larger numbers relative to the median.
2. **Sort the remaining 3 elements in stack A** (trivial case).
3. **Optimized insertion from B to A**, considering rotation cost (`resolve_num` in your code).
4. **Final rotation** to make the smallest number the top element.

